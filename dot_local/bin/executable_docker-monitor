#!/bin/bash

# Monitor de uso de Docker para Colima
# Alerta cuando el uso supera el 80% del límite configurado (3GB)
# Uso: docker-monitor

# Configuración
LIMIT_GB=3
WARNING_PERCENT=80
LIMIT_BYTES=$((LIMIT_GB * 1024 * 1024 * 1024))
WARNING_BYTES=$((LIMIT_BYTES * WARNING_PERCENT / 100))
MIN_HOURS_BETWEEN_RUNS=20  # Evitar ejecución múltiple el mismo día

# Archivo para guardar timestamp
LAST_RUN_FILE="$HOME/.cache/docker-monitor/last-run"

# Colores para salida en terminal
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Crear directorio de caché si no existe
mkdir -p "$(dirname "$LAST_RUN_FILE")"

# Función para convertir bytes a GB human-readable
bytes_to_gb() {
    local bytes=$1
    echo "scale=2; $bytes / 1024 / 1024 / 1024" | bc
}

# Función para obtener el uso total de Docker en bytes
get_docker_usage() {
    local system_df=$(docker system df --format '{{.Size}}' 2>/dev/null)
    local total_size=$(echo "$system_df" | head -1)
    local total_bytes=0
    
    if [[ $total_size =~ ^([0-9.]+)\s*(B|KB|MB|GB|TB)$ ]]; then
        local num=${BASH_REMATCH[1]}
        local unit=${BASH_REMATCH[2]}
        
        case $unit in
            B)   total_bytes=$(echo "$num" | awk '{print int($1)}') ;;
            KB)  total_bytes=$(echo "$num * 1024" | bc | awk '{print int($1)}') ;;
            MB)  total_bytes=$(echo "$num * 1024 * 1024" | bc | awk '{print int($1)}') ;;
            GB)  total_bytes=$(echo "$num * 1024 * 1024 * 1024" | bc | awk '{print int($1)}') ;;
            TB)  total_bytes=$(echo "$num * 1024 * 1024 * 1024 * 1024" | bc | awk '{print int($1)}') ;;
        esac
    fi
    
    echo $total_bytes
}

# Función para verificar si debe ejecutarse
should_run() {
    local force=$1
    
    # Si se fuerza con --force, siempre ejecutar
    if [[ "$force" == "true" ]]; then
        return 0
    fi
    
    # Si no existe el archivo, ejecutar
    if [[ ! -f "$LAST_RUN_FILE" ]]; then
        return 0
    fi
    
    # Leer último timestamp
    local last_run=$(cat "$LAST_RUN_FILE" 2>/dev/null)
    if [[ -z "$last_run" ]]; then
        return 0
    fi
    
    # Calcular horas transcurridas
    local current_time=$(date +%s)
    local hours_passed=$(( (current_time - last_run) / 3600 ))
    
    if [[ $hours_passed -ge $MIN_HOURS_BETWEEN_RUNS ]]; then
        return 0
    else
        echo -e "${BLUE}[INFO]${NC} Última ejecución hace $hours_passed horas. Mínimo requerido: $MIN_HOURS_BETWEEN_RUNS horas."
        echo -e "${BLUE}[INFO]${NC} Usa --force para ejecutar de todas formas."
        return 1
    fi
}

# Función para guardar timestamp
save_timestamp() {
    date +%s > "$LAST_RUN_FILE"
}

# Función para mostrar notificación nativa de macOS con botón
show_notification() {
    local current_gb=$1
    local limit_gb=$2
    local warning_gb=$3
    
    local result=$(osascript <<EOF
        display dialog "El uso de Docker ha alcanzado ${current_gb}GB de ${limit_gb}GB (límite: ${warning_gb}GB).\n\n¿Deseas limpiar ahora?" \
            buttons {"Más tarde", "Limpiar ahora"} \
            default button "Limpiar ahora" \
            with icon caution \
            with title "Docker Monitor - Uso Alto"
EOF
)
    
    if [[ $result == *"Limpiar ahora"* ]]; then
        return 0
    else
        return 1
    fi
}

# Función principal de monitoreo
monitor() {
    # Verificar si Docker/Colima está corriendo
    if ! docker info >/dev/null 2>&1; then
        echo -e "${YELLOW}[AVISO]${NC} Docker no está disponible. ¿Está Colima corriendo?"
        exit 0
    fi
    
    # Obtener uso actual
    local current_bytes=$(get_docker_usage)
    local current_gb=$(bytes_to_gb $current_bytes)
    local warning_gb=$(bytes_to_gb $WARNING_BYTES)
    
    echo -e "${BLUE}[INFO]${NC} Uso actual de Docker: ${current_gb}GB"
    echo -e "${BLUE}[INFO]${NC} Límite configurado: ${LIMIT_GB}GB"
    echo -e "${BLUE}[INFO]${NC} Umbral de advertencia (${WARNING_PERCENT}%): ${warning_gb}GB"
    
    # Verificar si supera el umbral
    if (( $(echo "$current_bytes > $WARNING_BYTES" | bc -l) )); then
        echo -e "${YELLOW}[ADVERTENCIA]${NC} Uso de Docker supera el ${WARNING_PERCENT}% del límite"
        
        # Mostrar notificación con botón
        if show_notification "$current_gb" "$LIMIT_GB" "$warning_gb"; then
            echo -e "${GREEN}[ACCION]${NC} Ejecutando limpieza..."
            docker-cleanup
        else
            echo -e "${YELLOW}[INFO]${NC} Limpieza pospuesta por el usuario"
        fi
    else
        echo -e "${GREEN}[OK]${NC} Uso de Docker dentro de límites normales"
    fi
    
    # Guardar timestamp de ejecución exitosa
    save_timestamp
}

# Parsear argumentos
FORCE_RUN=false
SHOW_INFO=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --manual|-m)
            SHOW_INFO=true
            shift
            ;;
        --force|-f)
            FORCE_RUN=true
            shift
            ;;
        *)
            shift
            ;;
    esac
done

# Ejecución manual
if [[ "$SHOW_INFO" == true ]]; then
    echo "======================================="
    echo "   Docker Monitor (Colima)"
    echo "======================================="
    echo ""
    
    if should_run "$FORCE_RUN"; then
        monitor
    fi
    
    echo ""
    echo "======================================="
    echo "   Configuración LaunchAgent"
    echo "======================================="
    echo ""
    echo "El monitor se ejecuta automáticamente vía launchd:"
    echo ""
    echo "Frecuencia: Cada 24 horas"
    echo "Inicio: Al iniciar sesión"
    echo "Control: Evita ejecución múltiple (mínimo ${MIN_HOURS_BETWEEN_RUNS}h entre ejecuciones)"
    echo ""
    echo "Comandos útiles:"
    echo "  launchctl list | grep docker-monitor     # Ver estado"
    echo "  launchctl unload ~/Library/LaunchAgents/com.user.docker-monitor.plist"
    echo "  launchctl load ~/Library/LaunchAgents/com.user.docker-monitor.plist"
    echo ""
    echo "Para forzar ejeción ignorando el tiempo:"
    echo "  docker-monitor --manual --force"
    echo ""
else
    # Ejecución silenciosa (para launchd)
    if should_run "$FORCE_RUN"; then
        monitor >/dev/null 2>&1
    fi
fi
